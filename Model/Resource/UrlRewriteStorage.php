<?php

namespace BigBridge\ProductImport\Model\Resource;

use BigBridge\ProductImport\Model\Data\SimpleProduct;
use BigBridge\ProductImport\Model\Db\Magento2DbConnection;

/**
 * @author Patrick van Bergen
 */
class UrlRewriteStorage
{
    /** @var  Magento2DbConnection */
    protected $db;

    /** @var  MetaData */
    protected $metaData;

    public function __construct(
        Magento2DbConnection $db,
        MetaData $metaData)
    {
        $this->db = $db;
        $this->metaData = $metaData;
    }

    /**
     * @param SimpleProduct[] $products
     */
    public function insertRewrites(array $products)
    {
        $newRewriteValues = $this->getNewRewriteValues($products);

        $this->writeNewRewrites($newRewriteValues);
    }

    public function updateRewrites(array $products)
    {
        $existingRewriteMap = $this->getExistingRewriteMap($products);

        $existingRewriteValues = array_keys($existingRewriteMap);
        $newRewriteValues = $this->getNewRewriteValues($products);

        $updates = array_diff($newRewriteValues, $existingRewriteValues);

        $this->writeRewrites($updates, $existingRewriteMap);
    }

    protected function writeRewrites(array $insertRewriteValues, $existingRewriteValues)
    {
        if (empty($insertRewriteValues)) {
            return;
        }

        $productIds = [];
        $cases = [];
        $oldUrlRewriteIds = [];
        foreach ($insertRewriteValues as $tabbedUpdate) {
            list($productId, $requestPath, $targetPath, $storeId, $metadata) = explode("\t", $tabbedUpdate);
            $productIds[] = $productId;

            if (array_key_exists($tabbedUpdate, $existingRewriteValues)) {
                $exist = $existingRewriteValues[$tabbedUpdate];
                $oldUrlRewriteIds[] = $exist['url_rewrite_id'];
                $previousRequestPath = $exist['request_path'];
                $cases[] = "WHEN `request_path` = '{$previousRequestPath}' AND `store_id` = {$storeId} THEN '{$requestPath}'\n";
            }
        }

        if (!empty($oldUrlRewriteIds)) {

            if (!$this->metaData->getSaveRewritesHistory()) {

                // remove currently active rewrites of given products from all store views
                $sql = "
                    DELETE FROM `{$this->metaData->urlRewriteTable}`
                    WHERE `url_rewrite_id` IN (" . $this->db->quoteSet($oldUrlRewriteIds) . ")
                ";

                $this->db->execute($sql);

            } else {

                // remove the index values
                $sql = "
                    DELETE FROM `{$this->metaData->urlRewriteProductCategoryTable}`
                    WHERE `url_rewrite_id` IN (" . $this->db->quoteSet($oldUrlRewriteIds) . ")
                ";

                $this->db->execute($sql);
            }

            // update existing rewrites to new active request_paths
            // metadata seems to change to empty array in Magento; i don't know why
            $sql = "
            UPDATE `{$this->metaData->urlRewriteTable}`
            SET 
                `redirect_type` = 301,
                `metadata` = IFNULL(`metadata`, '" . serialize([]) . "'),
                `target_path` = CASE
                " . implode($cases) . "
                END 
            WHERE     
                `entity_type` = 'product' AND 
                `entity_id` IN (" . $this->db->quoteSet($productIds) . ")
        ";

            $this->db->execute($sql);
        }

        $this->writeNewRewrites($insertRewriteValues);
    }

    protected function writeNewRewrites(array $tabbedRewriteValues)
    {
        if (empty($tabbedRewriteValues)) {
            return;
        }

        $newRewriteValues = [];
        foreach ($tabbedRewriteValues as $tabbedUpdate) {
            list($productId, $requestPath, $targetPath, $storeId, $metadata) = explode("\t", $tabbedUpdate);
            $metadata = $metadata === "" ? "null" : $this->db->quote($metadata);
            $requestPath = $this->db->quote($requestPath);
            $targetPath = $this->db->quote($targetPath);
            $newRewriteValues[] = "('product', {$productId}, {$requestPath}, {$targetPath}, 0, {$storeId}, 1, {$metadata})";
        }

        // add new values
        // IGNORE works on the key request_path, store_id
        // when this combination already exists, it is ignored
        // this may happen if a main product is followed by one of its store views
        $sql = "
                INSERT IGNORE INTO `{$this->metaData->urlRewriteTable}`
                (`entity_type`, `entity_id`, `request_path`, `target_path`, `redirect_type`, `store_id`, `is_autogenerated`, `metadata`)
                VALUES " . implode(', ', $newRewriteValues) . "
            ";

        $this->db->execute($sql);

        // the last insert id is guaranteed to be the first id generated
        $insertId = $this->db->getLastInsertId();

        if ($insertId != 0) {

            // the SUBSTRING_INDEX extracts the category id from the target_path
            $sql = "
                INSERT INTO `{$this->metaData->urlRewriteProductCategoryTable}` (`url_rewrite_id`, `category_id`, `product_id`)
                SELECT `url_rewrite_id`, SUBSTRING_INDEX(`target_path`, '/', -1), `entity_id`
                FROM `{$this->metaData->urlRewriteTable}`
                WHERE 
                    `url_rewrite_id` >= {$insertId} AND
                    `target_path` LIKE '%/category/%' 
            ";

            $this->db->execute($sql);
        }
    }

    protected function getNewRewriteValues(array $products): array
    {
        if (empty($products)) {
            return [];
        }

        // all store view ids, without 0
        $allStoreIds = array_diff($this->metaData->storeViewMap, ['0']);

        $productIds = array_column($products, 'id');
        $attributeId = $this->metaData->productEavAttributeInfo['url_key']->attributeId;

        $results = $this->db->fetchAllAssoc("
            SELECT `entity_id`, `store_id`, `value` AS `url_key`
            FROM `{$this->metaData->productEntityTable}_varchar`
            WHERE
                `attribute_id` = {$attributeId} AND
                `entity_id` IN (" . $this->db->quoteSet($productIds) . ")
        ");

        $urlKeys = [];
        foreach ($results as $result) {
            $productId = $result['entity_id'];
            $storeId = $result['store_id'];
            $urlKey = $result['url_key'];

            if ($storeId == 0) {
                // insert url key to all store views
                foreach ($allStoreIds as $aStoreId) {
                    // but do not overwrite explicit assignments
                    if (!array_key_exists($productId, $urlKeys) || !array_key_exists($aStoreId, $urlKeys[$productId])) {
                        $urlKeys[$productId][$aStoreId] = $urlKey;
                    }
                }
            } else {
                $urlKeys[$productId][$storeId] = $urlKey;
            }
        }

        // category ids per product
        $categoryIds = [];
        $results = $this->db->fetchAllAssoc("
            SELECT `product_id`, `category_id`
            FROM `{$this->metaData->categoryProductTable}`
            WHERE
                `product_id` IN (" . $this->db->quoteSet($productIds) .")
        ");

        $rewriteValues = [];
        foreach ($results as $result) {
            $categoryIds[$result['product_id']][$result['category_id']] = $result['category_id'];
        }

        foreach ($urlKeys as $productId => $urlKeyData) {
            foreach ($urlKeyData as $storeId => $urlKey) {

                $shortUrl = $urlKey . $this->metaData->productUrlSuffix;

                // url keys without categories
                $requestPath = $shortUrl;
                $targetPath = 'catalog/product/view/id/' . $productId;
                $rewriteValues[] = "{$productId}\t{$requestPath}\t{$targetPath}\t{$storeId}\t";

                if (!array_key_exists($productId, $categoryIds)) {
                    continue;
                }

                // url keys with categories
                foreach ($categoryIds[$productId] as $directCategoryId) {

                    // here we check if the category id supplied actually exists
                    if (!array_key_exists($directCategoryId, $this->metaData->allCategoryInfo)) {
                        continue;
                    }

                    $path = "";
                    foreach ($this->metaData->allCategoryInfo[$directCategoryId]->path as $i => $parentCategoryId) {

                        // the root category is not used for the url path
                        if ($i === 0) {
                            continue;
                        }

                        $categoryInfo = $this->metaData->allCategoryInfo[$parentCategoryId];

                        // take the url_key from the store view, or default to the global url_key
                        $urlKey = array_key_exists($storeId, $categoryInfo->urlKeys) ? $categoryInfo->urlKeys[$storeId] : $categoryInfo->urlKeys[0];

                        $path .= $urlKey . "/";

                        $requestPath = $path . $shortUrl;
                        $targetPath = 'catalog/product/view/id/' . $productId . '/category/' . $parentCategoryId;
                        $metadata = serialize(['category_id' => (string)$parentCategoryId]);
                        $rewriteValues[] = "{$productId}\t{$requestPath}\t{$targetPath}\t{$storeId}\t{$metadata}";
                    }
                }
            }
        }

        return $rewriteValues;
    }

    protected function getExistingRewriteMap(array $products)
    {
        if (empty($products)) {
            return [];
        }

        $productIds = array_column($products, 'id');

        $results = $this->db->fetchAllAssoc("
            SELECT `url_rewrite_id`, `entity_type`, `entity_id`, `request_path`, `target_path`, `store_id`, `metadata`, SUBSTRING_INDEX(`target_path`, '/', -1) as category_id
            FROM `{$this->metaData->urlRewriteTable}`
            WHERE 
                `entity_type` = 'product' AND
                `redirect_type` = 0 AND
                `entity_id` IN (" . $this->db->quoteSet($productIds) . ") 
        ");

        $rewriteValues = [];

        foreach ($results as $result) {
            $productId = $result['entity_id'];
            $requestPath = $result['request_path'];
            $targetPath = $result['target_path'];
            $storeId = $result['store_id'];
            $metadata = $result['metadata'];
            $urlRewiteId = $result['url_rewrite_id'];
            $rewriteValues["{$productId}\t{$requestPath}\t{$targetPath}\t{$storeId}\t{$metadata}"] = [
                'url_rewrite_id' => $urlRewiteId,
                'request_path' => $requestPath,
            ];
        }

        return $rewriteValues;
    }
}