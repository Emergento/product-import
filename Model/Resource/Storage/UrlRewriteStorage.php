<?php

namespace BigBridge\ProductImport\Model\Resource\Storage;

use BigBridge\ProductImport\Api\Data\Product;
use BigBridge\ProductImport\Api\Data\ProductStoreView;
use BigBridge\ProductImport\Model\Data\UrlRewrite;
use BigBridge\ProductImport\Model\Persistence\Magento2DbConnection;
use BigBridge\ProductImport\Model\Resource\MetaData;
use BigBridge\ProductImport\Model\Resource\Serialize\ValueSerializer;

/**
 * @author Patrick van Bergen
 */
class UrlRewriteStorage
{
    const NO_REDIRECT = 0;
    const REDIRECT = 301;

    const TARGET_PATH_BASE = 'catalog/product/view/id/';
    const TARGET_PATH_EXT = '/category/';

    /** @var  Magento2DbConnection */
    protected $db;

    /** @var  MetaData */
    protected $metaData;

    public function __construct(
        Magento2DbConnection $db,
        MetaData $metaData)
    {
        $this->db = $db;
        $this->metaData = $metaData;
    }

    /**
     * @param Product[] $products
     * @param ValueSerializer $valueSerializer
     */
    public function updateRewrites(array $products, ValueSerializer $valueSerializer)
    {
        $productIds = array_column($products, 'id');

        if (empty($productIds)) {
            $existingUrlRewrites = [];
            $allProductCategoryIds = [];
            $allProductUrlKeys = [];
            $allVisibilities = [];
        } else {
            $existingUrlRewrites = $this->getExistingUrlRewrites($productIds, $valueSerializer);
            $allProductCategoryIds = $this->getExistingProductCategoryIds($productIds);
            $allProductUrlKeys = $this->getExistingProductUrlKeys($productIds);
            $allVisibilities = $this->getExistingVisibilities($productIds);
        }

        // there are no global url_rewrites
        $allStoreIds = array_diff($this->metaData->storeViewMap, ['0']);

        foreach ($productIds as $productId) {

            $productCategoryIds = array_key_exists($productId, $allProductCategoryIds) ? $allProductCategoryIds[$productId] : [];

            foreach ($allStoreIds as $storeViewId) {

                if (isset($allVisibilities[$productId][$storeViewId])) {
                    $visibility = $allVisibilities[$productId][$storeViewId];
                } elseif (isset($allVisibilities[$productId][0])) {
                    $visibility = $allVisibilities[$productId][0];
                } else {
                    $visibility = null;
                }

                if ($visibility === null || $visibility === ProductStoreView::VISIBILITY_NOT_VISIBLE) {
                    continue;
                }

                $this->updateRewriteGroup($productId, $storeViewId, $existingUrlRewrites, $productCategoryIds, $allProductUrlKeys, $valueSerializer);
            }
        }
    }

    /**
     * @param int[] $productIds
     * @param ValueSerializer $valueSerializer
     * @return array
     */
    protected function getExistingUrlRewrites(array $productIds, ValueSerializer $valueSerializer)
    {
        $allStoreIds = array_diff($this->metaData->storeViewMap, ['0']);

        // group products by store view
        $collection = [];
        foreach ($productIds as $productId) {
            foreach ($allStoreIds as $storeViewId) {
                $collection[$storeViewId][] = $productId;
            }
        }

        $data = [];
        foreach ($collection as $storeId => $ids) {

            $urlRewriteData = $this->db->fetchAllAssoc("
                SELECT `url_rewrite_id`, `entity_id`, `request_path`, `target_path`, `redirect_type`, `metadata`, `is_autogenerated`
                FROM `{$this->metaData->urlRewriteTable}`
                WHERE
                    `store_id` = ? AND 
                    `entity_id` IN (" . $this->db->getMarks($ids) . ") AND
                    `entity_type` = 'product' AND
                    `redirect_type` = '0'
            ", array_merge([
                $storeId
            ], $ids));

            foreach ($urlRewriteData as $datum) {

                $categoryId = $valueSerializer->extract($datum['metadata'], 'category_id');

                $urlRewrite = new UrlRewrite($datum['url_rewrite_id'], $datum['entity_id'], $datum['request_path'],
                    $datum['target_path'], $datum['redirect_type'], $storeId, $categoryId, $datum['is_autogenerated']);

                $data[$storeId][$urlRewrite->getProductId()][$urlRewrite->getCategoryId()] = $urlRewrite;
            }
        }

        return $data;
    }

    /**
     * @param int[] $productIds
     * @return array
     */
    protected function getExistingProductCategoryIds(array $productIds)
    {
        $rows = $this->db->fetchAllAssoc("
            SELECT `product_id`, `category_id`
            FROM `{$this->metaData->categoryProductTable}`
            WHERE `product_id` IN (" . $this->db->getMarks($productIds) . ")
        ", $productIds);

        $categoryIds = [];
        foreach ($rows as $row) {
            $categoryIds[$row['product_id']][] = $row['category_id'];
        }

        return $categoryIds;
    }

    protected function getExistingProductUrlKeys(array $productIds)
    {
        $attributeId = $this->metaData->productEavAttributeInfo['url_key']->attributeId;

        $rows = $this->db->fetchAllAssoc("
            SELECT `entity_id`, `store_id`, `value`
            FROM `{$this->metaData->productEntityTable}_varchar`
            WHERE `entity_id` IN (" . $this->db->getMarks($productIds) . ") AND
                attribute_id = ?
        ", array_merge($productIds, [$attributeId]));

        $urlKeys = [];
        foreach ($rows as $row) {
            $urlKeys[$row['entity_id']][$row['store_id']] = $row['value'];
        }

        return $urlKeys;
    }

    protected function getExistingVisibilities(array $productIds)
    {
        $attributeId = $this->metaData->productEavAttributeInfo['visibility']->attributeId;

        $rows = $this->db->fetchAllAssoc("
            SELECT `entity_id`, `store_id`, `value`
            FROM `{$this->metaData->productEntityTable}_int`
            WHERE `entity_id` IN (" . $this->db->getMarks($productIds) . ") AND
                attribute_id = ?
        ", array_merge($productIds, [$attributeId]));

        $urlKeys = [];
        foreach ($rows as $row) {
            $urlKeys[$row['entity_id']][$row['store_id']] = (int)$row['value'];
        }

        return $urlKeys;
    }

    /**
     * @param int $productId
     * @param int $storeViewId
     * @param array $existingUrlRewrites
     * @param array $categoryIds
     * @param array $allProductUrlKeys
     * @param ValueSerializer $valueSerializer
     */
    protected function updateRewriteGroup(int $productId, int $storeViewId, array $existingUrlRewrites, array $categoryIds,
                                          array $allProductUrlKeys, ValueSerializer $valueSerializer)
    {
        $this->updateRewrite($productId, $storeViewId, null, $existingUrlRewrites, $allProductUrlKeys, $valueSerializer);

        $productCategoryIds = $this->collectSubcategories($categoryIds);

        foreach ($productCategoryIds as $categoryId) {
            $this->updateRewrite($productId, $storeViewId, $categoryId, $existingUrlRewrites, $allProductUrlKeys, $valueSerializer);
        }
    }

    /**
     * @param int[] $categoryIds
     * @return array
     */
    protected function collectSubcategories(array $categoryIds)
    {
        $subCategories = [];

        foreach ($categoryIds as $categoryId) {
            $categoryInfo = $this->metaData->allCategoryInfo[$categoryId];
            $subCategories = array_merge($subCategories, $categoryInfo->path);
        }

        return array_unique($subCategories);
    }

    /**
     * @param int $productId
     * @param int $storeViewId
     * @param int|null $categoryId
     * @param array $allProductUrlKeys
     * @return string|null
     */
    protected function createRequestPaths(int $productId, int $storeViewId, $categoryId, array $allProductUrlKeys)
    {
        $pieces = [];

        if ($categoryId !== null) {

            $categoryInfo = $this->metaData->allCategoryInfo[$categoryId];
            $parentIds = $categoryInfo->path;

            // 1st parent: root (1), 2nd parent: website root (has no url_key)
            if (count($parentIds) < 3) {
                return null;
            }

            for ($i = 2; $i < count($parentIds); $i++) {

                $parentId = $parentIds[$i];

                if (!array_key_exists($parentId, $this->metaData->allCategoryInfo)) {
                    // parent category in path (no longer) exists
                    return null;
                }

                $parentCategoryInfo = $this->metaData->allCategoryInfo[$parentId];

                if (array_key_exists($storeViewId, $parentCategoryInfo->urlKeys)) {
                    $section = $parentCategoryInfo->urlKeys[$storeViewId];
                } elseif (array_key_exists(0, $parentCategoryInfo->urlKeys)) {
                    $section = $parentCategoryInfo->urlKeys[0];
                } else {
                    // parent category has no url_key
                    return null;
                }

                $pieces[] = $section;
            }
        }

        // product url_key for store view (inherits from global)

        if (isset($allProductUrlKeys[$productId][$storeViewId])) {
            $productUrlKey =  $allProductUrlKeys[$productId][$storeViewId];
        } elseif (isset($allProductUrlKeys[$productId][0])) {
            $productUrlKey =  $allProductUrlKeys[$productId][0];
        } else {
            return null;
        }

        $pieces[] = $productUrlKey;

        return implode('/', $pieces) . $this->metaData->productUrlSuffix;
    }

    /**
     * @param int $productId
     * @param int $storeViewId
     * @param int|null $categoryId
     * @param array $existingUrlRewrites
     * @param array $allProductUrlKeys
     * @param ValueSerializer $valueSerializer
     */
    protected function updateRewrite(int $productId, int $storeViewId, $categoryId, array $existingUrlRewrites,
                                     array $allProductUrlKeys, ValueSerializer $valueSerializer)
    {
        /** @var UrlRewrite $existingRewrite */
        $existingRewrite = isset($existingUrlRewrites[$storeViewId][$productId][$categoryId])
            ? $existingUrlRewrites[$storeViewId][$productId][$categoryId] : null;

        // build new item
        $requestPath = $this->createRequestPaths($productId, $storeViewId, $categoryId, $allProductUrlKeys);
        if ($requestPath === null) {
            return;
        }

        $newRewrite = new UrlRewrite(
            null,
            $productId,
            $requestPath,
            self::TARGET_PATH_BASE . $productId . ($categoryId === null ? '' : self::TARGET_PATH_EXT . $categoryId),
            self::NO_REDIRECT,
            $storeViewId,
            $categoryId,
            true
        );

        if ($existingRewrite === null) {

            $this->insertUrlRewrite($newRewrite, $valueSerializer);

        } else {

            if (!$newRewrite->equals($existingRewrite)) {
                if ($this->metaData->saveRewritesHistory) {

                    // replace existing rewrite
                    $replacedRewrite = new UrlRewrite(
                        $existingRewrite->getUrlRewriteId(),
                        $existingRewrite->getProductId(),
                        $existingRewrite->getRequestPath(),
                        $requestPath,
                        self::REDIRECT,
                        $existingRewrite->getStoreId(),
                        $existingRewrite->getCategoryId(),
                        false
                    );

                    $this->removeIndex($existingRewrite->getUrlRewriteId());
                    $this->updateUrlRewrite($replacedRewrite, $valueSerializer);
                    $this->insertUrlRewrite($newRewrite, $valueSerializer);

                } else {

                    // replace existing rewrite
                    $replacedRewrite = new UrlRewrite(
                        $existingRewrite->getUrlRewriteId(),
                        $newRewrite->getProductId(),
                        $newRewrite->getRequestPath(),
                        $newRewrite->getTargetPath(),
                        self::NO_REDIRECT,
                        $newRewrite->getStoreId(),
                        $newRewrite->getCategoryId(),
                        true
                    );

                    $this->updateUrlRewrite($replacedRewrite, $valueSerializer);

                }
            }
        }
    }

    /**
     * @param UrlRewrite $urlRewrite
     * @param ValueSerializer $valueSerializer
     */
    protected function insertUrlRewrite(UrlRewrite $urlRewrite, ValueSerializer $valueSerializer)
    {
        // on duplicate key update is needed, for example when two products swap their url_key
        // otherwise a "duplicate key" error occurs
        // and there are many other cases
        $this->db->execute("
            INSERT INTO `{$this->metaData->urlRewriteTable}`
            SET
                `entity_type` = ?, 
                `entity_id` = ?, 
                `request_path` = ?, 
                `target_path` = ?, 
                `redirect_type` = ?, 
                `store_id` = ?, 
                `is_autogenerated` = ?, 
                `metadata` = ?
             ON DUPLICATE KEY UPDATE
                `entity_type` = VALUES(`entity_type`), 
                `entity_id` = VALUES(`entity_id`), 
                `target_path` = VALUES(`target_path`), 
                `redirect_type` = VALUES(`redirect_type`), 
                `is_autogenerated` = VALUES(`is_autogenerated`), 
                `metadata` = VALUES(`metadata`)
        ", [
            'product',
            $urlRewrite->getProductId(),
            $urlRewrite->getRequestPath(),
            $urlRewrite->getTargetPath(),
            $urlRewrite->getRedirectType(),
            $urlRewrite->getStoreId(),
            $urlRewrite->getAutogenerated(),
            $valueSerializer->serialize($urlRewrite->getMetadata())
        ]);

        if ($insertId = $this->db->getLastInsertId()) {

            if ($urlRewrite->getCategoryId() !== null) {

                $this->db->execute("
                    INSERT INTO `{$this->metaData->urlRewriteProductCategoryTable}` 
                    SET
                        `url_rewrite_id` = ?, 
                        `category_id` = ?, 
                        `product_id` = ?
                ", [
                    $insertId,
                    $urlRewrite->getCategoryId(),
                    $urlRewrite->getProductId()
                ]);
            }
        }
    }

    protected function removeIndex(int $urlRewriteId)
    {
        $this->db->execute("
            DELETE FROM `{$this->metaData->urlRewriteProductCategoryTable}` 
            WHERE
                `url_rewrite_id` = ?
        ", [
            $urlRewriteId
        ]);
    }

    /**
     * @param UrlRewrite $urlRewrite
     * @param ValueSerializer $valueSerializer
     */
    protected function updateUrlRewrite(UrlRewrite $urlRewrite, ValueSerializer $valueSerializer)
    {
        $this->db->execute("
            UPDATE `{$this->metaData->urlRewriteTable}`
            SET
                `entity_type` = 'product', 
                `entity_id` = ?, 
                `request_path` = ?, 
                `target_path` = ?, 
                `redirect_type` = ?, 
                `store_id` = ?, 
                `is_autogenerated` = ?, 
                `metadata` = ?
            WHERE
                `url_rewrite_id` = ?     
        ", [
            $urlRewrite->getProductId(),
            $urlRewrite->getRequestPath(),
            $urlRewrite->getTargetPath(),
            $urlRewrite->getRedirectType(),
            $urlRewrite->getStoreId(),
            $urlRewrite->getAutogenerated(),
            $valueSerializer->serialize($urlRewrite->getMetadata()),
            $urlRewrite->getUrlRewriteId()
        ]);
    }
}
