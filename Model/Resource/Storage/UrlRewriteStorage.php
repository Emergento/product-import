<?php

namespace BigBridge\ProductImport\Model\Resource\Storage;

use BigBridge\ProductImport\Api\Data\ProductStoreView;
use BigBridge\ProductImport\Model\Data\UrlRewrite;
use BigBridge\ProductImport\Model\Persistence\Magento2DbConnection;
use BigBridge\ProductImport\Model\Resource\MetaData;

/**
 * @author Patrick van Bergen
 */
class UrlRewriteStorage
{
    const NO_REDIRECT = 0;
    const REDIRECT = 301;

    const TARGET_PATH_BASE = 'catalog/product/view/id/';
    const TARGET_PATH_EXT = '/category/';

    /** @var  Magento2DbConnection */
    protected $db;

    /** @var  MetaData */
    protected $metaData;

    public function __construct(
        Magento2DbConnection $db,
        MetaData $metaData)
    {
        $this->db = $db;
        $this->metaData = $metaData;
    }

    public function updateRewrites(array $products)
    {
        $productIds = array_column($products, 'id');
        $nonGlobalStoreIds = $this->metaData->getNonGlobalStoreViewIds();

        $this->updateRewritesByProductIds($productIds, $nonGlobalStoreIds);
    }

    /**
     * @param int[] $productIds
     * @param array $storeViewIds
     */
    public function updateRewritesByProductIds(array $productIds, array $storeViewIds)
    {
        $existingUrlRewrites = $this->getExistingUrlRewrites($productIds, $storeViewIds);
        $allProductCategoryIds = $this->getExistingProductCategoryIds($productIds);
        $allProductUrlKeys = $this->getExistingProductUrlKeys($productIds);
        $allVisibilities = $this->getExistingVisibilities($productIds);

        foreach ($productIds as $productId) {

            $productCategoryIds = array_key_exists($productId, $allProductCategoryIds) ? $allProductCategoryIds[$productId] : [];

            foreach ($storeViewIds as $storeViewId) {

                if (isset($allVisibilities[$productId][$storeViewId])) {
                    $visibility = $allVisibilities[$productId][$storeViewId];
                } elseif (isset($allVisibilities[$productId][0])) {
                    $visibility = $allVisibilities[$productId][0];
                } else {
                    $visibility = null;
                }

                if ($visibility === null || $visibility === ProductStoreView::VISIBILITY_NOT_VISIBLE) {
                    continue;
                }

                $this->updateRewriteGroup($productId, $storeViewId, $existingUrlRewrites, $productCategoryIds, $allProductUrlKeys);
            }
        }
    }

    /**
     * @param int[] $productIds
     * @param array $allStoreIds
     * @return array
     */
    protected function getExistingUrlRewrites(array $productIds, array $allStoreIds)
    {
        if (empty($productIds)) {
            return [];
        }

        // group products by store view
        $collection = [];
        foreach ($productIds as $productId) {
            foreach ($allStoreIds as $storeViewId) {
                $collection[$storeViewId][] = $productId;
            }
        }

        $data = [];
        foreach ($collection as $storeId => $ids) {

            $urlRewriteData = $this->db->fetchAllAssoc("
                SELECT `url_rewrite_id`, `entity_id`, `request_path`, `target_path`, `redirect_type`, `metadata`, `is_autogenerated`
                FROM `{$this->metaData->urlRewriteTable}`
                WHERE
                    `store_id` = ? AND 
                    `entity_id` IN (" . $this->db->getMarks($ids) . ") AND
                    `entity_type` = 'product'
                ORDER BY `redirect_type`    
            ", array_merge([
                $storeId
            ], $ids));

            foreach ($urlRewriteData as $datum) {

                $categoryId = $this->metaData->valueSerializer->extract($datum['metadata'], 'category_id');

                $urlRewrite = new UrlRewrite($datum['url_rewrite_id'], $datum['entity_id'], $datum['request_path'],
                    $datum['target_path'], $datum['redirect_type'], $storeId, $categoryId, $datum['is_autogenerated']);

                $data[$storeId][$urlRewrite->getProductId()][(int)$urlRewrite->getCategoryId()][] = $urlRewrite;
            }
        }

        return $data;
    }

    /**
     * @param int[] $productIds
     * @return array
     */
    protected function getExistingProductCategoryIds(array $productIds)
    {
        if (empty($productIds)) {
            return [];
        }

        $rows = $this->db->fetchAllAssoc("
            SELECT `product_id`, `category_id`
            FROM `{$this->metaData->categoryProductTable}`
            WHERE `product_id` IN (" . $this->db->getMarks($productIds) . ")
        ", $productIds);

        $categoryIds = [];
        foreach ($rows as $row) {
            $categoryIds[$row['product_id']][] = $row['category_id'];
        }

        return $categoryIds;
    }

    protected function getExistingProductUrlKeys(array $productIds)
    {
        if (empty($productIds)) {
            return [];
        }

        $attributeId = $this->metaData->productEavAttributeInfo['url_key']->attributeId;

        $rows = $this->db->fetchAllAssoc("
            SELECT `entity_id`, `store_id`, `value`
            FROM `{$this->metaData->productEntityTable}_varchar`
            WHERE `entity_id` IN (" . $this->db->getMarks($productIds) . ") AND
                attribute_id = ?
        ", array_merge($productIds, [$attributeId]));

        $urlKeys = [];
        foreach ($rows as $row) {
            $urlKeys[$row['entity_id']][$row['store_id']] = $row['value'];
        }

        return $urlKeys;
    }

    protected function getExistingVisibilities(array $productIds)
    {
        if (empty($productIds)) {
            return [];
        }

        $attributeId = $this->metaData->productEavAttributeInfo['visibility']->attributeId;

        $rows = $this->db->fetchAllAssoc("
            SELECT `entity_id`, `store_id`, `value`
            FROM `{$this->metaData->productEntityTable}_int`
            WHERE `entity_id` IN (" . $this->db->getMarks($productIds) . ") AND
                attribute_id = ?
        ", array_merge($productIds, [$attributeId]));

        $urlKeys = [];
        foreach ($rows as $row) {
            $urlKeys[$row['entity_id']][$row['store_id']] = (int)$row['value'];
        }

        return $urlKeys;
    }

    /**
     * @param int $productId
     * @param int $storeViewId
     * @param array $existingUrlRewrites
     * @param array $categoryIds
     * @param array $allProductUrlKeys
     */
    protected function updateRewriteGroup(int $productId, int $storeViewId, array $existingUrlRewrites, array $categoryIds,
                                          array $allProductUrlKeys)
    {
        $this->updateRewrite($productId, $storeViewId, null, $existingUrlRewrites, $allProductUrlKeys);

        $productCategoryIds = $this->collectSubcategories($categoryIds);

        foreach ($productCategoryIds as $categoryId) {
            $this->updateRewrite($productId, $storeViewId, $categoryId, $existingUrlRewrites, $allProductUrlKeys);
        }

        // rewrites for categories that are no longer linked to the product are removed
        $this->removeObsoleteCategoryRewrites($productId, $storeViewId, $productCategoryIds, $existingUrlRewrites);
    }

    protected function removeObsoleteCategoryRewrites(int $productId, int $storeViewId, array $productCategoryIds, array $existingUrlRewrites)
    {
        if (isset($existingUrlRewrites[$storeViewId][$productId])) {

            // find the categories of all existing rewrites
            // and remove from these the actual categories, and 0 (for no category)
            $obsoleteCategoryIds = array_diff(array_keys($existingUrlRewrites[$storeViewId][$productId]), $productCategoryIds, [0]);

            foreach ($obsoleteCategoryIds as $categoriesId) {
                foreach ($existingUrlRewrites[$storeViewId][$productId][$categoriesId] as $urlRewrite) {
                    /** @var UrlRewrite $urlRewrite */
                    $this->removeUrlRewrite($urlRewrite->getUrlRewriteId());
                }
            }
        }
    }

    /**
     * @param int[] $categoryIds
     * @return array
     */
    protected function collectSubcategories(array $categoryIds)
    {
        $subCategories = [];

        foreach ($categoryIds as $categoryId) {
            $categoryInfo = $this->metaData->allCategoryInfo[$categoryId];
            $categoriesWithUrlKeysIds = array_slice($categoryInfo->path, 2);
            $subCategories = array_merge($subCategories, $categoriesWithUrlKeysIds);
        }

        return array_unique($subCategories);
    }

    /**
     * @param int $productId
     * @param int $storeViewId
     * @param int|null $categoryId
     * @param array $allProductUrlKeys
     * @return string|null
     */
    protected function createRequestPaths(int $productId, int $storeViewId, $categoryId, array $allProductUrlKeys)
    {
        $pieces = [];

        if ($categoryId !== null) {

            $categoryInfo = $this->metaData->allCategoryInfo[$categoryId];
            $parentIds = $categoryInfo->path;

            for ($i = 2; $i < count($parentIds); $i++) {

                $parentId = $parentIds[$i];

                if (!array_key_exists($parentId, $this->metaData->allCategoryInfo)) {
                    // parent category in path (no longer) exists
                    return null;
                }

                $parentCategoryInfo = $this->metaData->allCategoryInfo[$parentId];

                if (array_key_exists($storeViewId, $parentCategoryInfo->urlKeys)) {
                    $section = $parentCategoryInfo->urlKeys[$storeViewId];
                } elseif (array_key_exists(0, $parentCategoryInfo->urlKeys)) {
                    $section = $parentCategoryInfo->urlKeys[0];
                } else {
                    // parent category has no url_key
                    return null;
                }

                $pieces[] = $section;
            }
        }

        // product url_key for store view (inherits from global)

        if (isset($allProductUrlKeys[$productId][$storeViewId])) {
            $productUrlKey =  $allProductUrlKeys[$productId][$storeViewId];
        } elseif (isset($allProductUrlKeys[$productId][0])) {
            $productUrlKey =  $allProductUrlKeys[$productId][0];
        } else {
            return null;
        }

        $pieces[] = $productUrlKey;

        return implode('/', $pieces) . $this->metaData->productUrlSuffix;
    }

    /**
     * @param int $productId
     * @param int $storeViewId
     * @param int|null $categoryId
     * @param array $existingUrlRewrites
     * @param array $allProductUrlKeys
     */
    protected function updateRewrite(int $productId, int $storeViewId, $categoryId, array $existingUrlRewrites, array $allProductUrlKeys)
    {
        /** @var UrlRewrite $existingRewrite */
        $existingRewrite = isset($existingUrlRewrites[$storeViewId][$productId][(int)$categoryId])
            ? $existingUrlRewrites[$storeViewId][$productId][(int)$categoryId][0] : null;

        // build new item
        $requestPath = $this->createRequestPaths($productId, $storeViewId, $categoryId, $allProductUrlKeys);
        if ($requestPath === null) {
            return;
        }

        $targetPath = self::TARGET_PATH_BASE . $productId . ($categoryId === null ? '' : self::TARGET_PATH_EXT . $categoryId);

        $newRewrite = new UrlRewrite(null, $productId, $requestPath, $targetPath, self::NO_REDIRECT,
            $storeViewId, $categoryId, true);

        if ($existingRewrite === null) {

            $this->replaceIntoUrlRewrite($newRewrite);

        } else {

            if (!$newRewrite->equals($existingRewrite)) {
                if ($this->metaData->saveRewritesHistory) {

                    // replace existing rewrite
                    $replacedRewrite = new UrlRewrite($existingRewrite->getUrlRewriteId(), $existingRewrite->getProductId(), $existingRewrite->getRequestPath(),
                        $requestPath, self::REDIRECT, $existingRewrite->getStoreId(), $existingRewrite->getCategoryId(), false);

                    $this->removeIndex($existingRewrite->getUrlRewriteId());
                    // update is possible because request_path/store_id stays the same
                    $this->updateUrlRewrite($replacedRewrite);
                    // insert new key (replace into, because a request_path/store_id could already exist
                    $this->replaceIntoUrlRewrite($newRewrite);

                } else {

                    //rewrite the redirects that lead to this rewrite
                    $this->updateRedirectRewrites($storeViewId, $productId, $categoryId, $existingRewrite->getRequestPath(), $newRewrite->getRequestPath(), $existingUrlRewrites);

                    // replace existing rewrite
                    $replacedRewrite = new UrlRewrite($existingRewrite->getUrlRewriteId(), $existingRewrite->getProductId(), $newRewrite->getRequestPath(),
                        $existingRewrite->getTargetPath(), $existingRewrite->getRedirectType(), $existingRewrite->getStoreId(), $existingRewrite->getCategoryId(),
                        $existingRewrite->getAutogenerated());

                    // this was originally just an update,
                    // but request_path/store_id could already exist,
                    // replace into removes:
                    // - the old url_rewrite (because the url_rewrite_id)
                    // - any url_rewrites with the same request_path/store_id
                    $this->replaceIntoUrlRewrite($replacedRewrite);

                }
            }
        }
    }

    /**
     * @param $storeViewId
     * @param $productId
     * @param $categoryId
     * @param $newTargetPath
     * @param array $existingUrlRewrites
     */
    protected function updateRedirectRewrites($storeViewId, $productId, $categoryId, $oldTargetPath, $newTargetPath, array $existingUrlRewrites)
    {
        if (isset($existingUrlRewrites[$storeViewId][$productId][(int)$categoryId])) {
            foreach ($existingUrlRewrites[$storeViewId][$productId][(int)$categoryId] as $i => $existingRewrite) {

                if ($i === 0) {
                    continue;
                }

                /** @var UrlRewrite $existingRewrite */
                if ($existingRewrite->getTargetPath() === $oldTargetPath) {

                    // replace existing rewrite
                    $replacedRewrite = new UrlRewrite($existingRewrite->getUrlRewriteId(), $existingRewrite->getProductId(), $existingRewrite->getRequestPath(),
                        $newTargetPath, $existingRewrite->getRedirectType(), $existingRewrite->getStoreId(), $existingRewrite->getCategoryId(),
                        $existingRewrite->getAutogenerated());

                    $this->replaceIntoUrlRewrite($replacedRewrite);
                }
            }
        }
    }

    /**
     * @param UrlRewrite $urlRewrite
     */
    protected function replaceIntoUrlRewrite(UrlRewrite $urlRewrite)
    {
        // replace is needed, for example when two products swap their url_key
        // otherwise a "duplicate key" error occurs
        // and there are many other cases
        // also, the old entry in catalog_url_rewrite_product_category must be replaced
        $this->db->execute("
            REPLACE INTO `{$this->metaData->urlRewriteTable}`
            SET
                `url_rewrite_id` = ?,
                `entity_type` = ?, 
                `entity_id` = ?, 
                `request_path` = ?, 
                `target_path` = ?, 
                `redirect_type` = ?, 
                `store_id` = ?, 
                `is_autogenerated` = ?, 
                `metadata` = ?
        ", [
            $urlRewrite->getUrlRewriteId(), // null | integer
            'product',
            $urlRewrite->getProductId(),
            $urlRewrite->getRequestPath(),
            $urlRewrite->getTargetPath(),
            $urlRewrite->getRedirectType(),
            $urlRewrite->getStoreId(),
            $urlRewrite->getAutogenerated(),
            $this->metaData->valueSerializer->serialize($urlRewrite->getMetadata())
        ]);

        if ($urlRewrite->getCategoryId() !== null) {

            $this->db->execute("
                INSERT INTO `{$this->metaData->urlRewriteProductCategoryTable}` 
                SET
                    `url_rewrite_id` = LAST_INSERT_ID(), 
                    `category_id` = ?, 
                    `product_id` = ?
            ", [
                $urlRewrite->getCategoryId(),
                $urlRewrite->getProductId()
            ]);
        }
    }

    protected function removeIndex(int $urlRewriteId)
    {
        $this->db->execute("
            DELETE FROM `{$this->metaData->urlRewriteProductCategoryTable}` 
            WHERE
                `url_rewrite_id` = ?
        ", [
            $urlRewriteId
        ]);
    }

    protected function removeUrlRewrite(int $urlRewriteId)
    {
        $this->db->execute("
            DELETE FROM `{$this->metaData->urlRewriteTable}` 
            WHERE
                `url_rewrite_id` = ?
        ", [
            $urlRewriteId
        ]);
    }

    /**
     * @param UrlRewrite $urlRewrite
     */
    protected function updateUrlRewrite(UrlRewrite $urlRewrite)
    {
        $this->db->execute("
            UPDATE `{$this->metaData->urlRewriteTable}`
            SET
                `entity_type` = 'product', 
                `entity_id` = ?, 
                `request_path` = ?, 
                `target_path` = ?, 
                `redirect_type` = ?, 
                `store_id` = ?, 
                `is_autogenerated` = ?, 
                `metadata` = ?
            WHERE
                `url_rewrite_id` = ?     
        ", [
            $urlRewrite->getProductId(),
            $urlRewrite->getRequestPath(),
            $urlRewrite->getTargetPath(),
            $urlRewrite->getRedirectType(),
            $urlRewrite->getStoreId(),
            $urlRewrite->getAutogenerated(),
            $this->metaData->valueSerializer->serialize($urlRewrite->getMetadata()),
            $urlRewrite->getUrlRewriteId()
        ]);
    }
}
